/*
 * Pipedrive API v1
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::v1::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`authorize`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AuthorizeError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_tokens`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTokensError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`refresh_tokens`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RefreshTokensError {
    UnknownValue(serde_json::Value),
}


/// Authorize a user by redirecting them to the Pipedrive OAuth authorization page and request their permissions to act on their behalf. This step is necessary to implement only when you allow app installation outside of the Marketplace.
pub async fn authorize(configuration: &configuration::Configuration, client_id: &str, redirect_uri: &str, state: Option<&str>) -> Result<(), Error<AuthorizeError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_client_id = client_id;
    let p_redirect_uri = redirect_uri;
    let p_state = state;

    let uri_str = format!("{}/oauth/authorize", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("client_id", &p_client_id.to_string())]);
    req_builder = req_builder.query(&[("redirect_uri", &p_redirect_uri.to_string())]);
    if let Some(ref param_value) = p_state {
        req_builder = req_builder.query(&[("state", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<AuthorizeError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// After the customer has confirmed the app installation, you will need to exchange the `authorization_code` to a pair of access and refresh tokens. Using an access token, you can access the user's data through the API.
pub async fn get_tokens(configuration: &configuration::Configuration, authorization: &str, grant_type: Option<&str>, code: Option<&str>, redirect_uri: Option<&str>) -> Result<models::GetTokensResponse, Error<GetTokensError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_grant_type = grant_type;
    let p_code = code;
    let p_redirect_uri = redirect_uri;

    let uri_str = format!("{}/oauth/token", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("Authorization", p_authorization.to_string());
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    let mut multipart_form_params = std::collections::HashMap::new();
    if let Some(param_value) = p_grant_type {
        multipart_form_params.insert("grant_type", param_value.to_string());
    }
    if let Some(param_value) = p_code {
        multipart_form_params.insert("code", param_value.to_string());
    }
    if let Some(param_value) = p_redirect_uri {
        multipart_form_params.insert("redirect_uri", param_value.to_string());
    }
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetTokensResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetTokensResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTokensError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The `access_token` has a lifetime. After a period of time, which was returned to you in `expires_in` JSON property, the `access_token` will be invalid, and you can no longer use it to get data from our API. To refresh the `access_token`, you must use the `refresh_token`.
pub async fn refresh_tokens(configuration: &configuration::Configuration, authorization: &str, grant_type: Option<&str>, refresh_token: Option<&str>) -> Result<models::GetTokensResponse, Error<RefreshTokensError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_grant_type = grant_type;
    let p_refresh_token = refresh_token;

    let uri_str = format!("{}/oauth/token/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("Authorization", p_authorization.to_string());
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    let mut multipart_form_params = std::collections::HashMap::new();
    if let Some(param_value) = p_grant_type {
        multipart_form_params.insert("grant_type", param_value.to_string());
    }
    if let Some(param_value) = p_refresh_token {
        multipart_form_params.insert("refresh_token", param_value.to_string());
    }
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetTokensResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetTokensResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RefreshTokensError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

