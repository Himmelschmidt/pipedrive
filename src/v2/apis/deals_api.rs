/*
 * Pipedrive API v2
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 2.0.0
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::v2::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`add_deal`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AddDealError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`add_deal_follower`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AddDealFollowerError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`add_deal_product`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AddDealProductError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`convert_deal_to_lead`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ConvertDealToLeadError {
    Status404(models::GetConvertResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_additional_discount`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteAdditionalDiscountError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_deal`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteDealError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_deal_follower`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteDealFollowerError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_deal_product`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteDealProductError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_installment`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteInstallmentError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_additional_discounts`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAdditionalDiscountsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_archived_deals`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetArchivedDealsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_deal`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetDealError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_deal_conversion_status`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetDealConversionStatusError {
    Status404(models::GetConvertResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_deal_followers`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetDealFollowersError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_deal_followers_changelog`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetDealFollowersChangelogError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_deal_products`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetDealProductsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_deals`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetDealsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_deals_products`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetDealsProductsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_installments`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetInstallmentsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`post_additional_discount`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostAdditionalDiscountError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`post_installment`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostInstallmentError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`search_deals`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SearchDealsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_additional_discount`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateAdditionalDiscountError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_deal`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateDealError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_deal_product`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateDealProductError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_installment`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateInstallmentError {
    UnknownValue(serde_json::Value),
}


/// Adds a new deal.
pub async fn add_deal(configuration: &configuration::Configuration, add_deal_request: Option<models::AddDealRequest>) -> Result<models::UpsertDealResponse, Error<AddDealError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_add_deal_request = add_deal_request;

    let uri_str = format!("{}/deals", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-token", value);
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_add_deal_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UpsertDealResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UpsertDealResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AddDealError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Adds a user as a follower to the deal.
pub async fn add_deal_follower(configuration: &configuration::Configuration, id: i32, add_deal_follower_request: Option<models::AddDealFollowerRequest>) -> Result<models::AddFollowerResponse, Error<AddDealFollowerError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_add_deal_follower_request = add_deal_follower_request;

    let uri_str = format!("{}/deals/{id}/followers", configuration.base_path, id=p_id);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-token", value);
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_add_deal_follower_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AddFollowerResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AddFollowerResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AddDealFollowerError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Adds a product to a deal, creating a new item called a deal-product.
pub async fn add_deal_product(configuration: &configuration::Configuration, id: i32, add_deal_product_request: Option<models::AddDealProductRequest>) -> Result<models::AddDealProductResponse, Error<AddDealProductError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_add_deal_product_request = add_deal_product_request;

    let uri_str = format!("{}/deals/{id}/products", configuration.base_path, id=p_id);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-token", value);
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_add_deal_product_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AddDealProductResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AddDealProductResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AddDealProductError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Initiates a conversion of a deal to a lead. The return value is an ID of a job that was assigned to perform the conversion. Related entities (notes, files, emails, activities, ...) are transferred during the process to the target entity. There are exceptions for entities like invoices or history that are not transferred and remain linked to the original deal. If the conversion is successful, the deal is marked as deleted. To retrieve the created entity ID and the result of the conversion, call the <a href=\"https://developers.pipedrive.com/docs/api/v1/Deals#getDealConversionStatus\">/api/v2/deals/{deal_id}/convert/status/{conversion_id}</a> endpoint.
pub async fn convert_deal_to_lead(configuration: &configuration::Configuration, id: i32) -> Result<models::AddConvertDealToLeadResponse, Error<ConvertDealToLeadError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;

    let uri_str = format!("{}/deals/{id}/convert/lead", configuration.base_path, id=p_id);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-token", value);
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AddConvertDealToLeadResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AddConvertDealToLeadResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ConvertDealToLeadError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Removes a discount from a deal, changing the deal value if the deal has one-time products attached.
pub async fn delete_additional_discount(configuration: &configuration::Configuration, id: i32, discount_id: i32) -> Result<models::DeleteAdditionalDiscountResponse, Error<DeleteAdditionalDiscountError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_discount_id = discount_id;

    let uri_str = format!("{}/deals/{id}/discounts/{discount_id}", configuration.base_path, id=p_id, discount_id=p_discount_id);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-token", value);
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DeleteAdditionalDiscountResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DeleteAdditionalDiscountResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteAdditionalDiscountError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Marks a deal as deleted. After 30 days, the deal will be permanently deleted.
pub async fn delete_deal(configuration: &configuration::Configuration, id: i32) -> Result<models::DeleteDealResponse, Error<DeleteDealError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;

    let uri_str = format!("{}/deals/{id}", configuration.base_path, id=p_id);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-token", value);
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DeleteDealResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DeleteDealResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteDealError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Deletes a user follower from the deal.
pub async fn delete_deal_follower(configuration: &configuration::Configuration, id: i32, follower_id: i32) -> Result<models::DeleteFollowerResponse, Error<DeleteDealFollowerError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_follower_id = follower_id;

    let uri_str = format!("{}/deals/{id}/followers/{follower_id}", configuration.base_path, id=p_id, follower_id=p_follower_id);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-token", value);
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DeleteFollowerResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DeleteFollowerResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteDealFollowerError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Deletes a product attachment from a deal, using the `product_attachment_id`.
pub async fn delete_deal_product(configuration: &configuration::Configuration, id: i32, product_attachment_id: i32) -> Result<models::DeleteDealProductResponse, Error<DeleteDealProductError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_product_attachment_id = product_attachment_id;

    let uri_str = format!("{}/deals/{id}/products/{product_attachment_id}", configuration.base_path, id=p_id, product_attachment_id=p_product_attachment_id);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-token", value);
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DeleteDealProductResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DeleteDealProductResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteDealProductError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Removes an installment from a deal.  Only available in Advanced and above plans. 
pub async fn delete_installment(configuration: &configuration::Configuration, id: i32, installment_id: i32) -> Result<models::DeleteInstallmentResponse, Error<DeleteInstallmentError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_installment_id = installment_id;

    let uri_str = format!("{}/deals/{id}/installments/{installment_id}", configuration.base_path, id=p_id, installment_id=p_installment_id);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-token", value);
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DeleteInstallmentResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DeleteInstallmentResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteInstallmentError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Lists discounts attached to a deal.
pub async fn get_additional_discounts(configuration: &configuration::Configuration, id: i32) -> Result<models::GetAdditionalDiscountsResponse, Error<GetAdditionalDiscountsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;

    let uri_str = format!("{}/deals/{id}/discounts", configuration.base_path, id=p_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-token", value);
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetAdditionalDiscountsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetAdditionalDiscountsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetAdditionalDiscountsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns data about all archived deals.
pub async fn get_archived_deals(configuration: &configuration::Configuration, filter_id: Option<i32>, ids: Option<&str>, owner_id: Option<i32>, person_id: Option<i32>, org_id: Option<i32>, pipeline_id: Option<i32>, stage_id: Option<i32>, status: Option<&str>, updated_since: Option<&str>, updated_until: Option<&str>, sort_by: Option<&str>, sort_direction: Option<&str>, include_fields: Option<&str>, custom_fields: Option<&str>, limit: Option<i32>, cursor: Option<&str>) -> Result<models::GetDealsResponse, Error<GetArchivedDealsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_filter_id = filter_id;
    let p_ids = ids;
    let p_owner_id = owner_id;
    let p_person_id = person_id;
    let p_org_id = org_id;
    let p_pipeline_id = pipeline_id;
    let p_stage_id = stage_id;
    let p_status = status;
    let p_updated_since = updated_since;
    let p_updated_until = updated_until;
    let p_sort_by = sort_by;
    let p_sort_direction = sort_direction;
    let p_include_fields = include_fields;
    let p_custom_fields = custom_fields;
    let p_limit = limit;
    let p_cursor = cursor;

    let uri_str = format!("{}/deals/archived", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_filter_id {
        req_builder = req_builder.query(&[("filter_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_ids {
        req_builder = req_builder.query(&[("ids", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_owner_id {
        req_builder = req_builder.query(&[("owner_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_person_id {
        req_builder = req_builder.query(&[("person_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_org_id {
        req_builder = req_builder.query(&[("org_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_pipeline_id {
        req_builder = req_builder.query(&[("pipeline_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_stage_id {
        req_builder = req_builder.query(&[("stage_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_status {
        req_builder = req_builder.query(&[("status", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_updated_since {
        req_builder = req_builder.query(&[("updated_since", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_updated_until {
        req_builder = req_builder.query(&[("updated_until", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_sort_by {
        req_builder = req_builder.query(&[("sort_by", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_sort_direction {
        req_builder = req_builder.query(&[("sort_direction", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_include_fields {
        req_builder = req_builder.query(&[("include_fields", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_custom_fields {
        req_builder = req_builder.query(&[("custom_fields", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_cursor {
        req_builder = req_builder.query(&[("cursor", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-token", value);
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetDealsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetDealsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetArchivedDealsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns the details of a specific deal.
pub async fn get_deal(configuration: &configuration::Configuration, id: i32, include_fields: Option<&str>, custom_fields: Option<&str>) -> Result<models::UpsertDealResponse, Error<GetDealError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_include_fields = include_fields;
    let p_custom_fields = custom_fields;

    let uri_str = format!("{}/deals/{id}", configuration.base_path, id=p_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_include_fields {
        req_builder = req_builder.query(&[("include_fields", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_custom_fields {
        req_builder = req_builder.query(&[("custom_fields", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-token", value);
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UpsertDealResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UpsertDealResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetDealError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns information about the conversion. Status is always present and its value (not_started, running, completed, failed, rejected) represents the current state of the conversion. Lead ID is only present if the conversion was successfully finished. This data is only temporary and removed after a few days.
pub async fn get_deal_conversion_status(configuration: &configuration::Configuration, id: i32, conversion_id: &str) -> Result<models::GetConvertResponse1, Error<GetDealConversionStatusError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_conversion_id = conversion_id;

    let uri_str = format!("{}/deals/{id}/convert/status/{conversion_id}", configuration.base_path, id=p_id, conversion_id=crate::v2::apis::urlencode(p_conversion_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-token", value);
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetConvertResponse1`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetConvertResponse1`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetDealConversionStatusError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Lists users who are following the deal.
pub async fn get_deal_followers(configuration: &configuration::Configuration, id: i32, limit: Option<i32>, cursor: Option<&str>) -> Result<models::GetFollowersResponse, Error<GetDealFollowersError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_limit = limit;
    let p_cursor = cursor;

    let uri_str = format!("{}/deals/{id}/followers", configuration.base_path, id=p_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_cursor {
        req_builder = req_builder.query(&[("cursor", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-token", value);
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetFollowersResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetFollowersResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetDealFollowersError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Lists changelogs about users have followed the deal.
pub async fn get_deal_followers_changelog(configuration: &configuration::Configuration, id: i32, limit: Option<i32>, cursor: Option<&str>) -> Result<models::GetFollowerChangelogsResponse, Error<GetDealFollowersChangelogError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_limit = limit;
    let p_cursor = cursor;

    let uri_str = format!("{}/deals/{id}/followers/changelog", configuration.base_path, id=p_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_cursor {
        req_builder = req_builder.query(&[("cursor", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-token", value);
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetFollowerChangelogsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetFollowerChangelogsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetDealFollowersChangelogError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Lists products attached to a deal.
pub async fn get_deal_products(configuration: &configuration::Configuration, id: i32, cursor: Option<&str>, limit: Option<i32>, sort_by: Option<&str>, sort_direction: Option<&str>) -> Result<models::GetDealsProductsResponse, Error<GetDealProductsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_cursor = cursor;
    let p_limit = limit;
    let p_sort_by = sort_by;
    let p_sort_direction = sort_direction;

    let uri_str = format!("{}/deals/{id}/products", configuration.base_path, id=p_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_cursor {
        req_builder = req_builder.query(&[("cursor", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_sort_by {
        req_builder = req_builder.query(&[("sort_by", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_sort_direction {
        req_builder = req_builder.query(&[("sort_direction", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-token", value);
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetDealsProductsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetDealsProductsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetDealProductsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns data about all not archived deals.
pub async fn get_deals(configuration: &configuration::Configuration, filter_id: Option<i32>, ids: Option<&str>, owner_id: Option<i32>, person_id: Option<i32>, org_id: Option<i32>, pipeline_id: Option<i32>, stage_id: Option<i32>, status: Option<&str>, updated_since: Option<&str>, updated_until: Option<&str>, sort_by: Option<&str>, sort_direction: Option<&str>, include_fields: Option<&str>, custom_fields: Option<&str>, limit: Option<i32>, cursor: Option<&str>) -> Result<models::GetDealsResponse, Error<GetDealsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_filter_id = filter_id;
    let p_ids = ids;
    let p_owner_id = owner_id;
    let p_person_id = person_id;
    let p_org_id = org_id;
    let p_pipeline_id = pipeline_id;
    let p_stage_id = stage_id;
    let p_status = status;
    let p_updated_since = updated_since;
    let p_updated_until = updated_until;
    let p_sort_by = sort_by;
    let p_sort_direction = sort_direction;
    let p_include_fields = include_fields;
    let p_custom_fields = custom_fields;
    let p_limit = limit;
    let p_cursor = cursor;

    let uri_str = format!("{}/deals", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_filter_id {
        req_builder = req_builder.query(&[("filter_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_ids {
        req_builder = req_builder.query(&[("ids", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_owner_id {
        req_builder = req_builder.query(&[("owner_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_person_id {
        req_builder = req_builder.query(&[("person_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_org_id {
        req_builder = req_builder.query(&[("org_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_pipeline_id {
        req_builder = req_builder.query(&[("pipeline_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_stage_id {
        req_builder = req_builder.query(&[("stage_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_status {
        req_builder = req_builder.query(&[("status", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_updated_since {
        req_builder = req_builder.query(&[("updated_since", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_updated_until {
        req_builder = req_builder.query(&[("updated_until", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_sort_by {
        req_builder = req_builder.query(&[("sort_by", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_sort_direction {
        req_builder = req_builder.query(&[("sort_direction", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_include_fields {
        req_builder = req_builder.query(&[("include_fields", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_custom_fields {
        req_builder = req_builder.query(&[("custom_fields", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_cursor {
        req_builder = req_builder.query(&[("cursor", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-token", value);
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetDealsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetDealsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetDealsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns data about products attached to deals
pub async fn get_deals_products(configuration: &configuration::Configuration, deal_ids: Vec<i32>, cursor: Option<&str>, limit: Option<i32>, sort_by: Option<&str>, sort_direction: Option<&str>) -> Result<models::GetDealsProductsResponse, Error<GetDealsProductsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_deal_ids = deal_ids;
    let p_cursor = cursor;
    let p_limit = limit;
    let p_sort_by = sort_by;
    let p_sort_direction = sort_direction;

    let uri_str = format!("{}/deals/products", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = match "multi" {
        "multi" => req_builder.query(&p_deal_ids.into_iter().map(|p| ("deal_ids".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
        _ => req_builder.query(&[("deal_ids", &p_deal_ids.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
    };
    if let Some(ref param_value) = p_cursor {
        req_builder = req_builder.query(&[("cursor", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_sort_by {
        req_builder = req_builder.query(&[("sort_by", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_sort_direction {
        req_builder = req_builder.query(&[("sort_direction", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-token", value);
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetDealsProductsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetDealsProductsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetDealsProductsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Lists installments attached to a list of deals.  Only available in Advanced and above plans. 
pub async fn get_installments(configuration: &configuration::Configuration, deal_ids: Vec<i32>, cursor: Option<&str>, limit: Option<i32>, sort_by: Option<&str>, sort_direction: Option<&str>) -> Result<models::GetInstallmentsResponse, Error<GetInstallmentsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_deal_ids = deal_ids;
    let p_cursor = cursor;
    let p_limit = limit;
    let p_sort_by = sort_by;
    let p_sort_direction = sort_direction;

    let uri_str = format!("{}/deals/installments", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = match "multi" {
        "multi" => req_builder.query(&p_deal_ids.into_iter().map(|p| ("deal_ids".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
        _ => req_builder.query(&[("deal_ids", &p_deal_ids.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
    };
    if let Some(ref param_value) = p_cursor {
        req_builder = req_builder.query(&[("cursor", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_sort_by {
        req_builder = req_builder.query(&[("sort_by", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_sort_direction {
        req_builder = req_builder.query(&[("sort_direction", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-token", value);
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetInstallmentsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetInstallmentsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetInstallmentsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Adds a discount to a deal changing, the deal value if the deal has one-time products attached.
pub async fn post_additional_discount(configuration: &configuration::Configuration, id: i32, add_additional_discount_request_body: Option<models::AddAdditionalDiscountRequestBody>) -> Result<models::AddAdditionalDiscountResponse, Error<PostAdditionalDiscountError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_add_additional_discount_request_body = add_additional_discount_request_body;

    let uri_str = format!("{}/deals/{id}/discounts", configuration.base_path, id=p_id);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-token", value);
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_add_additional_discount_request_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AddAdditionalDiscountResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AddAdditionalDiscountResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PostAdditionalDiscountError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Adds an installment to a deal.  An installment can only be added if the deal includes at least one one-time product.  If the deal contains at least one recurring product, adding installments is not allowed.  Only available in Advanced and above plans. 
pub async fn post_installment(configuration: &configuration::Configuration, id: i32, add_installment_request_body: Option<models::AddInstallmentRequestBody>) -> Result<models::AddAInstallmentResponse, Error<PostInstallmentError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_add_installment_request_body = add_installment_request_body;

    let uri_str = format!("{}/deals/{id}/installments", configuration.base_path, id=p_id);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-token", value);
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_add_installment_request_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AddAInstallmentResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AddAInstallmentResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PostInstallmentError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Searches all deals by title, notes and/or custom fields. This endpoint is a wrapper of <a href=\"https://developers.pipedrive.com/docs/api/v1/ItemSearch#searchItem\">/v1/itemSearch</a> with a narrower OAuth scope. Found deals can be filtered by the person ID and the organization ID.
pub async fn search_deals(configuration: &configuration::Configuration, term: &str, fields: Option<&str>, exact_match: Option<bool>, person_id: Option<i32>, organization_id: Option<i32>, status: Option<&str>, include_fields: Option<&str>, limit: Option<i32>, cursor: Option<&str>) -> Result<models::GetDealSearchResponse, Error<SearchDealsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_term = term;
    let p_fields = fields;
    let p_exact_match = exact_match;
    let p_person_id = person_id;
    let p_organization_id = organization_id;
    let p_status = status;
    let p_include_fields = include_fields;
    let p_limit = limit;
    let p_cursor = cursor;

    let uri_str = format!("{}/deals/search", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("term", &p_term.to_string())]);
    if let Some(ref param_value) = p_fields {
        req_builder = req_builder.query(&[("fields", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_exact_match {
        req_builder = req_builder.query(&[("exact_match", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_person_id {
        req_builder = req_builder.query(&[("person_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_organization_id {
        req_builder = req_builder.query(&[("organization_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_status {
        req_builder = req_builder.query(&[("status", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_include_fields {
        req_builder = req_builder.query(&[("include_fields", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_cursor {
        req_builder = req_builder.query(&[("cursor", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-token", value);
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetDealSearchResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetDealSearchResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SearchDealsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Edits a discount added to a deal, changing the deal value if the deal has one-time products attached.
pub async fn update_additional_discount(configuration: &configuration::Configuration, id: i32, discount_id: i32, update_additional_discount_request_body: Option<models::UpdateAdditionalDiscountRequestBody>) -> Result<models::UpdateAdditionalDiscountResponse, Error<UpdateAdditionalDiscountError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_discount_id = discount_id;
    let p_update_additional_discount_request_body = update_additional_discount_request_body;

    let uri_str = format!("{}/deals/{id}/discounts/{discount_id}", configuration.base_path, id=p_id, discount_id=p_discount_id);
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-token", value);
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_update_additional_discount_request_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UpdateAdditionalDiscountResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UpdateAdditionalDiscountResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateAdditionalDiscountError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Updates the properties of a deal.
pub async fn update_deal(configuration: &configuration::Configuration, id: i32, update_deal_request: Option<models::UpdateDealRequest>) -> Result<models::UpsertDealResponse, Error<UpdateDealError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_update_deal_request = update_deal_request;

    let uri_str = format!("{}/deals/{id}", configuration.base_path, id=p_id);
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-token", value);
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_update_deal_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UpsertDealResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UpsertDealResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateDealError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Updates the details of the product that has been attached to a deal.
pub async fn update_deal_product(configuration: &configuration::Configuration, id: i32, product_attachment_id: i32, update_deal_product_request: Option<models::UpdateDealProductRequest>) -> Result<models::AddDealProductResponse, Error<UpdateDealProductError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_product_attachment_id = product_attachment_id;
    let p_update_deal_product_request = update_deal_product_request;

    let uri_str = format!("{}/deals/{id}/products/{product_attachment_id}", configuration.base_path, id=p_id, product_attachment_id=p_product_attachment_id);
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-token", value);
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_update_deal_product_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AddDealProductResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AddDealProductResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateDealProductError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Edits an installment added to a deal.  Only available in Advanced and above plans. 
pub async fn update_installment(configuration: &configuration::Configuration, id: i32, installment_id: i32, update_installment_request_body: Option<models::UpdateInstallmentRequestBody>) -> Result<models::UpdateInstallmentResponse, Error<UpdateInstallmentError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_installment_id = installment_id;
    let p_update_installment_request_body = update_installment_request_body;

    let uri_str = format!("{}/deals/{id}/installments/{installment_id}", configuration.base_path, id=p_id, installment_id=p_installment_id);
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-token", value);
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_update_installment_request_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UpdateInstallmentResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UpdateInstallmentResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateInstallmentError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

