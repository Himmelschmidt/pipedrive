/*
 * Pipedrive API v2
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 2.0.0
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::v2::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`search_item`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SearchItemError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`search_item_by_field`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SearchItemByFieldError {
    UnknownValue(serde_json::Value),
}


/// Performs a search from your choice of item types and fields.
pub async fn search_item(configuration: &configuration::Configuration, term: &str, item_types: Option<&str>, fields: Option<&str>, search_for_related_items: Option<bool>, exact_match: Option<bool>, include_fields: Option<&str>, limit: Option<i32>, cursor: Option<&str>) -> Result<models::GetItemSearchResponse, Error<SearchItemError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_term = term;
    let p_item_types = item_types;
    let p_fields = fields;
    let p_search_for_related_items = search_for_related_items;
    let p_exact_match = exact_match;
    let p_include_fields = include_fields;
    let p_limit = limit;
    let p_cursor = cursor;

    let uri_str = format!("{}/itemSearch", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("term", &p_term.to_string())]);
    if let Some(ref param_value) = p_item_types {
        req_builder = req_builder.query(&[("item_types", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_fields {
        req_builder = req_builder.query(&[("fields", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_search_for_related_items {
        req_builder = req_builder.query(&[("search_for_related_items", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_exact_match {
        req_builder = req_builder.query(&[("exact_match", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_include_fields {
        req_builder = req_builder.query(&[("include_fields", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_cursor {
        req_builder = req_builder.query(&[("cursor", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-token", value);
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetItemSearchResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetItemSearchResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SearchItemError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Performs a search from the values of a specific field. Results can either be the distinct values of the field (useful for searching autocomplete field values), or the IDs of actual items (deals, leads, persons, organizations or products).
pub async fn search_item_by_field(configuration: &configuration::Configuration, term: &str, entity_type: &str, field: &str, r#match: Option<&str>, limit: Option<i32>, cursor: Option<&str>) -> Result<models::GetItemSearchFieldResponse, Error<SearchItemByFieldError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_term = term;
    let p_entity_type = entity_type;
    let p_field = field;
    let p_match = r#match;
    let p_limit = limit;
    let p_cursor = cursor;

    let uri_str = format!("{}/itemSearch/field", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("term", &p_term.to_string())]);
    req_builder = req_builder.query(&[("entity_type", &p_entity_type.to_string())]);
    if let Some(ref param_value) = p_match {
        req_builder = req_builder.query(&[("match", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("field", &p_field.to_string())]);
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_cursor {
        req_builder = req_builder.query(&[("cursor", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-token", value);
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetItemSearchFieldResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetItemSearchFieldResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SearchItemByFieldError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

